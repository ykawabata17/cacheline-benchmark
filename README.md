# cacheline-benchmark

キャッシュライン最適化の効果を異なるプログラミング言語で比較するためのベンチマークスイートです。

# 概要

このリポジトリでは、大規模な配列に対して行方向および列方向のアクセスを行い、その実行時間を Python、Ruby、C、Go、Rust、言語で比較しています。  
これにより、キャッシュラインの利用がプログラムのパフォーマンスに与える影響と、各言語がメモリアクセスパターンをどのように処理するかを明らかにします。

# ベンチマークの詳細

ベンチマークは以下の2種類の操作を行います：

行方向アクセス (row_col)： 配列の要素を行ごとに順番にアクセスします。メモリ上の配置とアクセスパターンが一致するため、キャッシュ効率が高まります。
列方向アクセス (col_row)： 配列の要素を列ごとにアクセスします。メモリ上の配置とアクセスパターンが不一致となり、キャッシュミスが増加します。

ベンチマークの結果や考察はこちら(リリースされたらリンクを張る)のブログを参照してください。

# C 言語と Rust の最適化について

## C言語

最適化には様々なオプションがありますが、今回使用しているのは以下に上げるものだけです。

* `-O0`: 最適化なし（デフォルト）  
  コンパイルが速く、デバッグに適している
* `-O1`: 基本的な最適化  
  実行速度が向上するが、コンパイル時間は微増
* `-O2`: より高度な最適化  
  多くのプログラムでパフォーマンスが大幅に向上する
* `-O3`: 最大限の最適化  
  ループのアンローリングや関数のインライン化など、高度な最適化が行われるが、コンパイル時間が増える
* `-Ofast`: 最高速度を目指した最適化  
  標準準拠を一部無視する

ここでは`-O3`を使用しています。

* `-march=native`: 実行環境の CPU アーキテクチャに最適化されたコードを生成  
  CPU 固有の命令セット（SEE、AVX、NEON など）を使用できるようになる

* `-mtune=native`: 実行環境の CPU に合わせて、コードの実行速度を最適化する  
  CPU のパイプラインやキャッシュサイズなどを考慮したスケジューリングが行われるようになる

## Rust

コンパイル時に最適化したいので、`Cargo.toml`に最適化を行うオプションを追加しています。

* opt-level
  * 最適化レベル
  * 最高のレベル3に設定する
* codegen-units
  * コード生成時に何個の「コード生成ユニット」に分割するか
  * コード生成ユニットが多いほど最適化を阻害する可能性がある
  * 最小数の1に設定する

# ベンチマークの実行方法

## 前提条件

各言語のコンパイラやインタプリタをインストールしてください。
Python：バージョン3.x
Ruby：バージョン3.x
Go：最新の安定版
Rust：最新の安定版（rustup でインストールを推奨）
C：GCCまたはClang

## 手順

1. リポジトリをクローンします
```bash
$ git clone https://github.com/ykawabata17/cacheline-benchmark.git
$ cd cacheline-benchmark
```

2. 全言語のベンチマークを実行します
  - オプションで配列の要素数と処理の繰り返し回数を指定できます
  - ブログでは 要素数: 10240, 繰り返し回数: 5 としています
```bash
$ chmod 755 benchmarks.sh
$ ./benchmarks.sh
> 二次元配列のサイズ（行数と列数）を入力してください:
> サイズ: 10240 ↓
> 平均を取るための処理の繰り返し回数を入力してください:
> 繰り返し回数: 5 ↓
> ベンチマークを開始します...
```

3. 結果は実行したシェルスクリプトと同じ階層の results.csv に記録されます

## グラフの作成方法

Pythonのスクリプトを使用して、結果を視覚化することができます。

### 必要なライブラリのインストール

```bash
# データの整形に使用する
$ pip install pandas
# グラフ描写に使用する
$ pip install pandas matplotlib
# ※グラフに書き込む日本語の文字化けを防ぐため、japanize-matplotlib を使用
$ pip install japanize-matplotlib
```

### グラフを作成する

```bash
$ python graph.py
```

graph 配下にグラフが作成されています。